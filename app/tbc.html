<!doctype html>
<html>
  <head>
    <style>
      * { margin: 0; padding: 0; }
      canvas {
        display: block;
        position: absolute;
        top: 0;
        left: 0;
      }

      #title {
        color: #FFF;
        z-index: 1;
        position: fixed;
        top: 10px;
        left: 10px;
      }
    </style>
  </head>
  <body>
    <h3 id="title"></h3>
    <script src="./third-party/three.js"></script>
    <script src="./src/markov.js"></script>
    <script>
      /// Returns cube vertex data at index.
      function cubeVertex(index) {
        return { position: tbc_geometry.vertices[index],
                 color: tbc_geometry.colors[index] };
      };

      /// Convert a grid position into a cube index.
      function cubeIndex(x, y, z) {
        if (Array.isArray(x)) {
          y = x[1];
          z = x[2];
          x = x[0];
        }
        var level = Math.min(y, 2) * 9;
        var left = Math.min(x, 2) * 3;
        var depth = Math.min(z, 2);
        return level + left + depth;
      }

      /// Returns a random position in a cube.
      function randomPosition(size) {
        var size = size || 3;
        return [Math.floor(Math.random() * size),
                Math.floor(Math.random() * size),
                Math.floor(Math.random() * size)
        ];
      }

      function randomIndex(size) {
        var size = size || 3;
        return Math.floor(Math.random() * size);
      }

      function randomizePosition(position, size) {
        var size = size || 3;
        position.forEach(function (value, index) {
          position[index] = Math.floor(Math.random() * size);
        })
      }

      function constrainToCube(arr, dims) {
        var dims = (dims - 1) || 2;
        arr.forEach(function (value, index) {
          arr[index] = Math.max(Math.min(value, dims), 0);
        });
      }

      /// Activate a position with a decay
      function activate(p, color) {
      	var color = color || active_color;
        p.color.set(color);
      }

      var width, height;

      var renderer = new THREE.WebGLRenderer({ antialias: false });
      var scene = new THREE.Scene();
      var camera = new THREE.PerspectiveCamera(60);
      camera.position.z = 20;
      camera.position.y = 2.5;
      camera.lookAt(new THREE.Vector3());

      var geometry = new THREE.BoxGeometry(10, 10, 10);
      var material = new THREE.MeshBasicMaterial({
        color: 'red',
        wireframe: true
      });
      var cube = new THREE.Mesh(geometry, material);
      cube.rotation.velocity = new THREE.Vector3();
      // scene.add(cube);

      var tbc_geometry = new THREE.Geometry();
      var inactive_color = new THREE.Color(0x333333),
          active_color = new THREE.Color(0xFF00FF),
		alt_color = new THREE.Color(0x0099ff),
          color_fade_rate = 0.03;

      for (var y = 1; y >= -1; y -=1) {
        for (var x = -1; x <= 1; x +=1) {
          for (var z = -1; z <= 1; z += 1) {
            tbc_geometry.vertices.push(new THREE.Vector3(x * 0.5, y * 0.5, z * 0.5));
            tbc_geometry.colors.push(active_color.clone());
          }
        }
      }

      function build_static_cube() {

      }

      var tbc_material = new THREE.PointsMaterial({
        size: 4,
        vertexColors: THREE.VertexColors,
        map: THREE.ImageUtils.loadTexture("img/ring.png"),
        transparent: true
      });
      var tbc_mesh = new THREE.Points(tbc_geometry, tbc_material);
      tbc_mesh.scale.set(10, 10, 10);
      scene.add(tbc_mesh);

      function never() { return false; }
      function nothing() {}

      function createWalker(opt) {
        var opt = opt || {},
            walker = {},
            position = [0, 0, 0],
            updateTime = Date.now(),
            time = 0,
            ms_per_step = opt.ms || 500,
            step_fn = opt.step_fn || randomIndex,
            reset_condition = opt.reset_condition || never,
            reset_fn = opt.reset_fn || nothing;

        function start() {
          updateTime = Date.now();
          time = 0;
          reset_fn(position);
        }

        function update(color) {
          var now = Date.now(),
              dt = now - updateTime;
          updateTime = now;
          time += dt;

          if (time > ms_per_step) {
            activate(cubeVertex(cubeIndex(position)), color);
            if (reset_condition(position)) {
              reset_fn(position);
            }
            else {
              step_fn(position);
            }

            time -= ms_per_step;
          }
        }

        walker.start = start;
        walker.update = update;
        return walker;
      }

      var other_walker = markov.makeNode("Diagonal", createWalker({ms: 1000,
        step_fn: function (pos) {
          pos[0] -= 1;
          pos[1] -= 1;
          constrainToCube(pos);
        },
        reset_condition: function (pos) {
          return pos[0] <= 0 && pos[1] <= 1;
        },
        reset_fn: function (pos) {
          randomizePosition(pos);
          pos[0] = 2;
          pos[1] = 2;
        }
      }));
      var current_walker = markov.makeNode("Right To Left", createWalker({ms: 1000, step_fn: function (pos) {
        pos[0] -= 1;
        constrainToCube(pos);
      }, reset_condition: function (pos) {
        return pos[0] <= 0;
      }, reset_fn: function (pos) {
        randomizePosition(pos);
        pos[0] = 2;
      }
      }));

      var random_walk = markov.makeNode("Random Walk", createWalker({ms: 1000,
        step_fn: function (pos) {
          function random_offset() {
            return Math.floor(Math.random() * 3) - 1;
          }
          pos.forEach(function (value, index){
            pos[index] += random_offset();
          });
          constrainToCube(pos);
        }
      }));

      current_walker = random_walk;

      setup();

      function setup() {

        document.body.appendChild(renderer.domElement);
        window.addEventListener('resize', resize, false);
        resize();

        loop();

      }

      function resize() {

        width = window.innerWidth;
        height = window.innerHeight;

        renderer.setSize(width, height);
        camera.aspect = width / height;
        camera.updateProjectionMatrix();

      }

      var time = 0,
          seconds_per_mode = 10.0;

      function loop() {

        requestAnimationFrame(loop);
        renderer.render(scene, camera);

        cube.rotation.add(cube.rotation.velocity);
        cube.scale.copy(cube.rotation.velocity);

        cube.scale.x = Math.abs(cube.scale.x) + 1;
        cube.scale.y = Math.abs(cube.scale.y) + 1;
        cube.scale.z = Math.abs(cube.scale.z) + 1;

        tbc_geometry.colors.forEach(function (color) {
          color.lerp(inactive_color, color_fade_rate);
        });
        tbc_geometry.colorsNeedUpdate = true;

        time += 1 / 60.0;
        if (time > seconds_per_mode) {
          time = 0;
          current_walker = current_walker.randomExit();
          other_walker = other_walker.randomExit();
          current_walker.start();
          other_walker.start();
          console.log("Changed to:", current_walker.markov.name);
          document.getElementById("title").textContent = current_walker.markov.name + ":" + other_walker.markov.name;
        }
        current_walker.update(active_color);
	other_walker.update(alt_color);
      }

    </script>
  </body>
</html>
